// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IRouterClient} from "@ccip/contracts/src/v0.8/ccip/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@ccip/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@ccip/contracts/src/v0.8/ccip/libraries/Client.sol";
import {CCIPReceiver} from "@ccip/contracts/src/v0.8/ccip/applications/CCIPReceiver.sol";

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract RebaseToken is ERC20, Ownable {
    uint256 public constant PRECISION_FACTOR = 1e18; // Used to handle fixed-point calculations
    address public s_pool; // the pool address (needed for access modifiers)
    // this keeps track of the interest rate of the user at the time they last bridged and their destination tokens were updated to mint any accrued interest since they last bridged.
    mapping(address => uint256) public s_userInterestRate;
    // keep track of the timestamp when they last bridged or transferred their tokens. This will be the last time their balance was updated to mint accrued interest.
    mapping(address => uint256) public s_userLastUpdatedTimestamp;
    uint256 public s_interestRate;

    event UserInterestRateUpdated(address indexed user, uint256 newUserInterestRate);
    event ToInterestAccrued(address user, uint256 balance);
    event FromInterestAccrued(address user, uint256 balance);

    error RebaseToken__SenderNotPool(address pool, address sender);

    constructor() Ownable(msg.sender) ERC20("RebaseToken", "RBT") {}

    function getPool() external view returns (address) {
        return s_pool;
    }

    /**
     * @dev returns the interest rate of the user
     * @param _user the address of the user
     * @return the interest rate of the user
     *
     */
    function getUserInterestRate(address _user) external view returns (uint256) {
        return s_userInterestRate[_user];
    }

    function setInterestRate(uint256 _interestRate) external onlyOwner {
        s_interestRate = _interestRate;
    }

    /**
     * @dev updates the interest rate. This is called only by the pool when a user bridges to this chain.
     * @param _interestRate the new interest rate
     * @notice this is called when a bridges tokens to this chain
     *
     */
    function setUserInterestRate(address _user, uint256 _interestRate) external {
        // update the user's interest rate
        s_userInterestRate[_user] = s_interestRate;
        // update the user's last updated timestamp to the current block timestamp
        s_userLastUpdatedTimestamp[_user] = block.timestamp;
        emit UserInterestRateUpdated(_user, _interestRate);
    }

    /**
     * @dev calculates the balance of the user, which is the
     * principal balance + interest generated by the principal balance
     * @param _user the user for which the balance is being calculated
     * @return the total balance of the user
     *
     */
    function balanceOf(address _user) public view override returns (uint256) {
        //current principal balance of the user
        uint256 currentPrincipalBalance = super.balanceOf(_user);
        if (currentPrincipalBalance == 0) {
            return 0;
        }
        // shares * current accumulated interest for that user since their interest was last minted to them.
        // do not need to normalize with the global accumulate interest as each individual user's interest is kept track of and there is no accumulatedInterest since the interest rate is static for users who have bridges. accumulated interest is only needed on the source token since the interest rate is updated by the protocol.
        return (currentPrincipalBalance * _calculateUserAccumulatedInterestSinceLastUpdate(_user) / PRECISION_FACTOR);
    }

    /**
     * @dev returns the principal balance of the user. The principal balance is the last
     * updated stored balance, which does not consider the perpetually accruing interest.
     * @param _user the address of the user
     * @return the principal balance of the user
     *
     */
    function principalBalanceOf(address _user) external view returns (uint256) {
        return super.balanceOf(_user);
    }

    /// @notice Mints new tokens for a given address.
    /// @param account The address to mint the new tokens to.
    /// @param amount The number of tokens to be minted.
    /// @dev this function increases the total supply.
    function mint(address _account, uint256 _value) public override onlyPool {
        _beforeUpdate(address(0), _account, _value);
        setUserInterestRate(_account, s_interestRate);
        _mint(_account, _value);
    }

    /// @notice Burns tokens from the sender.
    /// @param amount The number of tokens to be burned.
    /// @dev this function decreases the total supply.
    function burn(address _account, uint256 _value) public override onlyPool {
        _beforeUpdate(_account, address(0), _value);
        _burn(_account, _value);
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        // accumulates the balance of the user so it is up to date with any interest accumulated.
        // also sets the user's accumulated rate (source token) or last updated timestamp (destination token)
        _beforeUpdate(msg.sender, recipient, s_userInterestRate[msg.sender]);
        if (s_userInterestRate[recipient] != 0) {
            setUserInterestRate(recipient, s_interestRate);
        }
        return super.transfer(recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        // accumulates the balance of the user so it is up to date with any interest accumulated.
        // also sets the user's accumulated rate (source token) or last updated timestamp (destination token)
        _beforeUpdate(sender, recipient);
        if (s_userInterestRate[recipient] != 0) {
            setUserInterestRate(recipient, s_interestRate);
        }
        return super.transferFrom(sender, recipient, amount);
    }

    /**
     * @dev returns the interest accrued since the last update of the user's balance - aka since the last time the interest accrued was minted to the user.
     * @return the interest gained since the last update
     *
     */
    function _calculateUserAccumulatedInterestSinceLastUpdate(address _user) internal view returns (uint256) {
        uint256 timeDifference = block.timestamp - s_userLastUpdatedTimestamp[_user];
        // represents the linear growth over time = 1 + (interest rate * time)
        uint256 linearInterest = (s_userInterestRate[_user] * timeDifference) + PRECISION_FACTOR;
        // Calculate the total amount accumulated since the last update
        return linearInterest;
    }

    /**
     * @dev accumulates the accrued interest of the user to the principal balance. This function mints the users accrued interest since they last transferred or bridged tokens.
     * @param _user the address of the user for which the interest is being minted
     * @return the users new balance
     *
     */
    function _mintAccruedInterest(address _user) internal override returns (uint256) {
        // Get the user's previous principal balance. The amount of tokens they had last time their interest was minted to them.
        uint256 previousPrincipalBalance = super.balanceOf(_user);

        // Calculate the accrued interest since the last accumulation
        // `balanceOf` uses the user's interest rate and the time since their last update to get the updated balance
        uint256 currentBalance = balanceOf(_user);
        uint256 balanceIncrease = currentBalance - previousPrincipalBalance;

        // Mint an amount of tokens equivalent to the interest accrued
        _mint(_user, balanceIncrease);
        // Update the user's last updated timestamp to reflect this most recent time their interest was minted to them.
        s_userLastUpdatedTimestamp[_user] = block.timestamp;
        return (currentBalance);
    }

    /**
     * @dev executes the transfer of tokens, invoked by _transfer(), _mint() and _burn()
     * @param _from the address from which transfer the tokens
     * @param _to the destination address
     * @param _value the amount to transfer
     *
     */
    function _beforeUpdate(address _from, address _to, uint256 _value, uint256 _interestRate) internal override {
        if (_from != address(0)) {
            // we are burning or transferring tokens
            // mint any accrued interest since the last time the user's balance was updated
            (uint256 fromBalance) = _mintAccruedInterest(_from);
            if (fromBalance - _value == 0) {
                // NOTE: do i need to do this?
                s_userInterestRate[_from] = 0;
                s_userLastUpdatedTimestamp[_from] = 0;
            }
            emit FromInterestAccrued(_from, fromBalance);
        }
        if (_to != address(0)) {
            // we are minting or transferring tokens
            // mint any accrued interest since the last time the user's balance was updated
            (uint256 toBalance) = _mintAccruedInterest(_to);
            s_userInterestRate[_to] = _interestRate;
            emit ToInterestAccrued(_to, toBalance);
        }
    }
}
