// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

// NOTE: name, symbol, decimals need to be included
contract RebaseTokenBase is ERC20, Ownable {
    uint256 constant PRECISION_FACTOR = 10 ** 27; // Used to handle fixed-point calculations
    uint256 public s_interestRate = 5e5; // teeny tiny
    //Initial rate of 1 * precision AKA no growth
    uint256 public s_accumulatedInterest = PRECISION_FACTOR; // The amount of interest that has accumulated UP TO when s_interestRate was last updated.
    uint256 public s_lastUpdatedTimestamp; // the time when s_interestrate and s_accumulatedInterest were last updated
    address public s_pool; // the pool address (needed for access modifiers)

    mapping(address => uint256) public s_userAccumulatedRates; // NOTE: spelling, do I change to interestGained

    event ToInterestAccrued(address user, uint256 balance);
    event FromInterestAccrued(address user, uint256 balance);

    constructor() Ownable(msg.sender) ERC20("RebaseToken", "RBT") {
        s_lastUpdatedTimestamp = block.timestamp;
    }

    /**
     * @dev returns the last index of the user, used to calculate the balance of the user
     * @param _user address of the user
     * @return the last user index
     *
     */
    function getUserAccumulatedRate(address _user) external view returns (uint256) {
        return s_userAccumulatedRates[_user];
    }

    function getPool() external view returns (address) {
        return s_pool;
    }

    /**
     * @dev calculates the balance of the user, which is the
     * principal balance + interest generated by the principal balance
     * @param _user the user for which the balance is being calculated
     * @return the total balance of the user
     *
     */
    function balanceOf(address _user) public view override returns (uint256) {
        //current principal balance of the user
        uint256 currentPrincipalBalance = super.balanceOf(_user);
        if (currentPrincipalBalance == 0) {
            return 0;
        }
        // shares * current accumulated interest / interest when they deposited (or interest was minted to them)
        return currentPrincipalBalance * _calculateAccumulatedInterestSinceLastUpdate() / s_userAccumulatedRates[_user];
    }

    /**
     * @dev returns the principal balance of the user. The principal balance is the last
     * updated stored balance, which does not consider the perpetually accruing interest.
     * @param _user the address of the user
     * @return the principal balance of the user
     *
     */
    function principalBalanceOf(address _user) external view returns (uint256) {
        return super.balanceOf(_user);
    }

    /**
     * @dev calculates the total supply of the specific aToken
     * since the balance of every single user increases over time, the total supply
     * does that too.
     * @return the current total supply
     *
     */
    function totalSupply() public view override returns (uint256) {
        uint256 currentSupplyPrincipal = super.totalSupply();

        if (currentSupplyPrincipal == 0) {
            return 0;
        }

        return currentSupplyPrincipal * _calculateAccumulatedInterestSinceLastUpdate();
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _beforeUpdate(msg.sender, recipient, amount);
        return super.transfer(recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _beforeUpdate(sender, recipient, amount);
        return super.transferFrom(sender, recipient, amount);
    }

    /**
     * @dev executes the transfer of aTokens, invoked by both _transfer() and
     *      transferOnLiquidation()
     * @param _from the address from which transfer the aTokens
     * @param _to the destination address
     * @param _value the amount to transfer
     *
     */
    function _beforeUpdate(address _from, address _to, uint256 _value) internal {
        if (_from != address(0)) {
            // we are burning or transferring tokens
            (, uint256 fromBalance,,) = _applyAccruedInterest(_from);
            if (fromBalance - _value == 0) {
                s_userAccumulatedRates[_from] = 0;
            }
            emit FromInterestAccrued(_from, fromBalance);
        }
        if (_to != address(0)) {
            // we are minting or transferring tokens
            (, uint256 toBalance,,) = _applyAccruedInterest(_to);
            emit ToInterestAccrued(_to, toBalance);
        }
    }

    /**
     * @dev returns the normalized income of the rebase token
     * @return the normalized income
     *
     */
    function _calculateAccumulatedInterestSinceLastUpdate() internal view returns (uint256) {
        uint256 timeDifference = block.timestamp - s_lastUpdatedTimestamp;
        // represents the linear growth over time = 1 + (interest rate * time)
        uint256 linearInterest = s_interestRate * timeDifference + PRECISION_FACTOR;
        // Calculate the total amount accumulated since the last update
        return s_accumulatedInterest * linearInterest / PRECISION_FACTOR;
    }

    /**
     * @dev accumulates the accrued interest of the user to the principal balance
     * @param _user the address of the user for which the interest is being accumulated
     * @return the previous principal balance, the new principal balance, the balance increase
     * and the new user index
     *
     */
    function _applyAccruedInterest(address _user) internal returns (uint256, uint256, uint256, uint256) {
        //NOTE: DO they lose this is updateAccumlatedRate is called
        //NOTE: make internal function / make it public
        uint256 previousPrincipalBalance = super.balanceOf(_user);

        // Calculate the accrued interest since the last accumulation
        // `balanceOf` uses the accumulated rate to get the updated balance
        uint256 currentBalance = balanceOf(_user);
        uint256 balanceIncrease = currentBalance - previousPrincipalBalance;

        // Mint an amount of tokens equivalent to the interest accrued
        _mint(_user, balanceIncrease);

        // Update the user's index to reflect the new state
        s_userAccumulatedRates[_user] = _calculateAccumulatedInterestSinceLastUpdate(); // NOTE: check this (is it an index or an amount)
        return (previousPrincipalBalance, currentBalance, balanceIncrease, s_userAccumulatedRates[_user]);
    }
}
