// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

// NOTE: name, symbol, decimals need to be included
contract RebaseTokenBase is ERC20, Ownable {
    uint256 public constant UINT_MAX_VALUE = type(uint256).max; //NOTE: how can I not use this? where is it used?
    uint256 constant PRECISION_FACTOR = 10 ** 27; // Used to handle fixed-point calculations
    uint256 public s_interestRate = 5 * PRECISION_FACTOR / 1000;
    uint256 public s_accumulatedRate = PRECISION_FACTOR; // Initial rate of 1 (no growth)
    uint256 public s_lastUpdatedTimestamp;
    address public s_pool;

    mapping(address => uint256) public userIndexes; // NOTE: spelling, do I change to interestGained

    event CumulativeIndexUpdated(uint256 index, uint256 timestamp);
    event Mint(address indexed user, uint256 amount, uint256 balance, uint256 index);
    event Burn(address indexed user, uint256 amount, uint256 balance, uint256 index);

    error RebaseToken__AmountGreaterThanBalance(uint256 amount, uint256 balance);
    error RebaseToken__SenderNotPool(address pool, address sender);
    error RebaseToken__CannotTransferZero();

    constructor() Ownable(msg.sender) ERC20("RebaseToken", "RBT") {
        s_lastUpdatedTimestamp = block.timestamp;
    }

    modifier onlyPool() {
        if (msg.sender != s_pool) {
            revert RebaseToken__SenderNotPool(s_pool, msg.sender);
        }
        _;
    }

    /**
     * @dev calculates the balance of the user, which is the
     * principal balance + interest generated by the principal balance
     * @param _user the user for which the balance is being calculated
     * @return the total balance of the user
     *
     */
    function balanceOf(address _user) public view override returns (uint256) {
        //current principal balance of the user
        uint256 currentPrincipalBalance = super.balanceOf(_user);
        if (currentPrincipalBalance == 0) {
            return 0;
        }
        // shares * current accumulated interest / interest when they deposited (or interest was minted to them)
        return currentPrincipalBalance * _calculateAccumulatedInterest() / userIndexes[_user];
    }

    /**
     * @dev returns the principal balance of the user. The principal balance is the last
     * updated stored balance, which does not consider the perpetually accruing interest.
     * @param _user the address of the user
     * @return the principal balance of the user
     *
     */
    function principalBalanceOf(address _user) external view returns (uint256) {
        return super.balanceOf(_user);
    }

    /**
     * @dev calculates the total supply of the specific aToken
     * since the balance of every single user increases over time, the total supply
     * does that too.
     * @return the current total supply
     *
     */
    function totalSupply() public view override returns (uint256) {
        uint256 currentSupplyPrincipal = super.totalSupply();

        if (currentSupplyPrincipal == 0) {
            return 0;
        }

        return currentSupplyPrincipal * _calculateAccumulatedInterest();
    }

    /**
     * @dev returns the last index of the user, used to calculate the balance of the user
     * @param _user address of the user
     * @return the last user index
     *
     */
    function getUserIndex(address _user) external view returns (uint256) {
        return userIndexes[_user];
    }

    function getPool() external view returns (address) {
        return s_pool;
    }

    /**
     * @dev accumulates the accrued interest of the user to the principal balance
     * @param _user the address of the user for which the interest is being accumulated
     * @return the previous principal balance, the new principal balance, the balance increase
     * and the new user index
     *
     */
    function _applyAccruedInterest(address _user) internal returns (uint256, uint256, uint256, uint256) {
        //NOTE: DO they lose this is updateAccumlatedRate is called
        //NOTE: make internal function / make it public
        uint256 previousPrincipalBalance = super.balanceOf(_user);

        // Calculate the accrued interest since the last accumulation
        // `balanceOf` uses the accumulated rate to get the updated balance
        uint256 currentBalance = balanceOf(_user);
        uint256 balanceIncrease = currentBalance - previousPrincipalBalance;

        // Mint an amount of tokens equivalent to the interest accrued
        _mint(_user, balanceIncrease);

        // Update the user's index to reflect the new state
        userIndexes[_user] = _calculateAccumulatedInterest(); // NOTE: check this (is it an index or an amount)
        return (previousPrincipalBalance, currentBalance, balanceIncrease, userIndexes[_user]);
    }

    /**
     * @dev returns the normalized income of the rebase token
     * @return the normalized income
     *
     */
    function _calculateAccumulatedInterest() internal view returns (uint256) {
        uint256 timeDifference = block.timestamp - s_lastUpdatedTimestamp;
        // represents the linear growth over time = 1 + (interest rate * time)
        uint256 linearInterest = s_interestRate * timeDifference + PRECISION_FACTOR;
        // Calculate the total amount accumulated since the last update
        return s_accumulatedRate * linearInterest / PRECISION_FACTOR;
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _beforeUpdate(msg.sender, recipient, amount);
        return super.transfer(recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _beforeUpdate(sender, recipient, amount);
        return super.transferFrom(sender, recipient, amount);
    }

    /**
     * @dev executes the transfer of aTokens, invoked by both _transfer() and
     *      transferOnLiquidation()
     * @param _from the address from which transfer the aTokens
     * @param _to the destination address
     * @param _value the amount to transfer
     *
     */
    function _beforeUpdate(address _from, address _to, uint256 _value) internal {
        if (_from != address(0)) {
            // we are burning or transferring tokens
            (uint256 fromPreviousBalance, uint256 fromBalance, uint256 fromBalanceIncrease, uint256 fromIndex) =
                _applyAccruedInterest(_from);
            if (fromBalance - _value == 0) {
                userIndexes[_from] = 0;
            }
        }
        if (_to != address(0)) {
            // we are minting or transferring tokens
            (uint256 toPreviousBalance, uint256 toBalance, uint256 toBalanceIncrease, uint256 toIndex) =
                _applyAccruedInterest(_to);
        }
    }
}
