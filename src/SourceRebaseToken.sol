// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IRouterClient} from "@ccip/contracts/src/v0.8/ccip/interfaces/IRouterClient.sol";
import {Client} from "@ccip/contracts/src/v0.8/ccip/libraries/Client.sol";

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

import {RebaseTokenBase} from "./RebaseTokenBase.sol";

contract SourceRebaseToken is RebaseTokenBase {
    address public s_vault;
    uint256 public s_interestRate = 5e10; // interestRate per second. (0.0005 % per second)
    uint256 public s_accumulatedInterest = PRECISION_FACTOR; // The amount of interest that has accumulated UP TO when s_interestRate was last updated. Initially "1".
    uint256 public s_lastUpdatedTimestamp; // the time when s_interestrate and s_accumulatedInterest were last updated
    mapping(address => uint256) public s_userAccumulatedInterest;

    event VaultAndPoolSet(address vault, address pool);
    event AccumulatedInterestUpdated(uint256 index, uint256 timestamp);
    event InterestRateUpdated(uint256 newInterestRate);

    error RebaseToken__SenderNotPoolOrVault(address sender);

    constructor() RebaseTokenBase() {
        s_lastUpdatedTimestamp = block.timestamp;
    }

    modifier onlyPoolOrVault() {
        if (msg.sender != s_pool && msg.sender != s_vault) {
            revert RebaseToken__SenderNotPoolOrVault(msg.sender);
        }
        _;
    }

    function getInterestRate() external view returns (uint256) {
        return s_interestRate;
    }
    /**
     * @dev returns the last index of the user, used to calculate the balance of the user
     * @param _user address of the user
     * @return the last user index
     *
     */

    function getUserAccumulatedRate(address _user) external view returns (uint256) {
        return s_userAccumulatedInterest[_user];
    }

    function setVaultAndPool(address vault, address pool) external onlyOwner {
        s_vault = vault;
        s_pool = pool;
        emit VaultAndPoolSet(vault, pool);
    }

    /**
     * @dev calculates the balance of the user, which is the
     * principal balance + interest generated by the principal balance
     * @param _user the user for which the balance is being calculated
     * @return the total balance of the user
     *
     */
    function balanceOf(address _user) public view override returns (uint256) {
        //current principal balance of the user
        uint256 currentPrincipalBalance = super.balanceOf(_user);
        if (currentPrincipalBalance == 0) {
            return 0;
        }
        // shares * current accumulated interest / interest when they deposited (or interest was last minted to them)
        return (currentPrincipalBalance * _calculateAccumulatedInterestSinceLastUpdate())
            / s_userAccumulatedInterest[_user];
    }

    /**
     * @dev calculates the total supply of the specific aToken
     * since the balance of every single user increases over time, the total supply
     * does that too.
     * @return the current total supply
     *
     */
    // NOTE: since I cannot do this in the dest token, shall I remove and just have totalSupply not reflect unminted interest?
    function totalSupply() public view override returns (uint256) {
        uint256 currentSupplyPrincipal = super.totalSupply();

        if (currentSupplyPrincipal == 0) {
            return 0;
        }

        return currentSupplyPrincipal * _calculateAccumulatedInterestSinceLastUpdate();
    }

    /// @notice Mints new tokens for a given address.
    /// @param account The address to mint the new tokens to.
    /// @param amount The number of tokens to be minted.
    /// @dev this function increases the total supply.
    function mint(address account, uint256 amount) public override onlyPoolOrVault {
        super.mint(account, amount);
    }

    /// @notice Burns tokens from the sender.
    /// @param amount The number of tokens to be burned.
    /// @dev this function decreases the total supply.
    function burn(address account, uint256 amount) public override onlyPoolOrVault {
        super.burn(account, amount);
    }

    /**
     * @dev updates the interest rate
     * @param interestRate the new interest rate
     * @notice this is called periodically (e.g. every day by automation) to decrease the interest rate
     *
     */
    function setInterestRate(uint256 interestRate) external onlyOwner {
        // we need to add the interest accumulated to s_accumulatedInterest UP TO when the interest rate changes so that it accouts for all historical interest up to that point.
        _updateAccumulatedInterest();
        s_interestRate = interestRate;
        emit InterestRateUpdated(interestRate);
    }

    /**
     * @dev returns the normalized income of the rebase token
     * @return the normalized income
     *
     */
    function _calculateAccumulatedInterestSinceLastUpdate() internal view returns (uint256) {
        uint256 timeDifference = block.timestamp - s_lastUpdatedTimestamp;
        // represents the linear growth over time = 1 + (interest rate * time)
        uint256 linearInterest = s_interestRate * timeDifference + PRECISION_FACTOR;
        // Calculate the total amount accumulated since the last update
        return (s_accumulatedInterest * linearInterest) / PRECISION_FACTOR;
    }

    /**
     * @dev accumulates the accrued interest of the user to the principal balance
     * @param _user the address of the user for which the interest is being accumulated
     * @return the previous principal balance, the new principal balance, the balance increase
     * and the new user index
     *
     */
    function _mintAccruedInterest(address _user) internal override returns (uint256) {
        //NOTE: DO they lose this is updateAccumlatedInterest is called? - NO but why? Because s_accumulatedInterest contains the needed info:)
        uint256 previousPrincipalBalance = super.balanceOf(_user);

        // Calculate the accrued interest since the last accumulation
        // `balanceOf` uses the accumulated interest to get the updated balance
        uint256 currentBalance = balanceOf(_user);
        uint256 balanceIncrease = currentBalance - previousPrincipalBalance;

        // Mint an amount of tokens equivalent to the interest accrued
        _mint(_user, balanceIncrease);

        // Update the user's index to reflect the new state
        s_userAccumulatedInterest[_user] = _calculateAccumulatedInterestSinceLastUpdate(); // this is a proxy for time but also includes the interest rate and accumulated interest.
        return (currentBalance);
    }

    /**
     * @dev updates the accumulated interest and the last updated timestamp
     * @notice this function should be called every time the interest rate changes.
     * @dev s_accumulatedInterest holds the accumulated interest multiplier UP TO when the interest most recently was updated. It therefore holds all historical interest rates.
     * @dev individual balances etc. will individually calculate any interest that has accumulated since interest rate was last updated since it will be linear witht time.
     *
     */
    function _updateAccumulatedInterest() internal {
        // Calculate the updated accumulated interest
        s_accumulatedInterest = _calculateAccumulatedInterestSinceLastUpdate();
        s_lastUpdatedTimestamp = block.timestamp;
        emit AccumulatedInterestUpdated(s_accumulatedInterest, s_lastUpdatedTimestamp);
    }

    // /**
    //  * @dev executes the transfer of aTokens, invoked by both _transfer() and
    //  *      transferOnLiquidation()
    //  * @param _from the address from which transfer the aTokens
    //  * @param _to the destination address
    //  * @param _value the amount to transfer
    //  *
    //  */
    // function _beforeUpdate(address _from, address _to, uint256 _value) internal override {
    //     if (_from != address(0)) {
    //         // we are burning or transferring tokens
    //         (uint256 fromBalance) = _mintAccruedInterest(_from);
    //         // if (fromBalance - _value == 0) {
    //         //     // NOTE: do I need to do this cos if I don't then I canput it in the base.
    //         //     s_userAccumulatedInterest[_from] = 0;
    //         // }
    //         emit FromInterestAccrued(_from, fromBalance);
    //     }
    //     if (_to != address(0)) {
    //         // we are minting or transferring tokens
    //         (uint256 toBalance) = _mintAccruedInterest(_to);
    //         emit ToInterestAccrued(_to, toBalance);
    //     }
    // }
}
